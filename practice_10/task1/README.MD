# Практическая работа №10  
## Анализ производительности CPU-параллельной программы (OpenMP)
В данной работе исследуется производительность параллельной программы на **C++ с использованием OpenMP**.  
В качестве тестовой задачи выполняется обработка большого массива данных с вычислением **суммы, среднего значения и дисперсии**.

## Цель работы
- реализовать базовую параллельную программу с OpenMP;
- выполнить измерение времени выполнения с помощью `omp_get_wtime()`;
- изучить влияние числа потоков на ускорение;
- оценить долю последовательной и параллельной части программы;
- проанализировать результаты с точки зрения **закона Амдала**.

## Описание реализации
Программа включает:
- **последовательную версию** вычислений (baseline);
- **параллельную версию** с использованием директивы  
  `#pragma omp parallel for reduction(...)`;
- измерение времени:
  - инициализации данных,
  - последовательных вычислений,
  - параллельных вычислений при разном числе потоков.
Для параллельной версии используются редукции по сумме и сумме квадратов элементов массива.

## Экспериментальная установка
- Размер массива: `N = 10 000 000`
- Максимальное число потоков: до `16`
- Измерение времени: `omp_get_wtime()`
- Окружение: CPU, OpenMP
Тестирование проводится для разного числа потоков:  
`1, 2, 4, 8, 16`.

## Анализ производительности
- Ускорение вычисляется относительно последовательной версии.
- Эффективность оценивается как отношение ускорения к числу потоков.
- Последовательная доля программы оценивается по формуле закона Амдала на основе измеренного ускорения.

Результаты показывают, что при увеличении числа потоков ускорение быстро насыщается из-за наличия существенной последовательной части и накладных расходов на управление потоками.

## Вывод
Практическая работа демонстрирует:
- базовые принципы параллелизации на CPU с использованием OpenMP;
- влияние числа потоков на ускорение и эффективность;
- ограничения масштабируемости параллельных программ, описываемые законом Амдала.
Даже при хорошо параллелизуемой вычислительной части общая производительность существенно ограничивается последовательными этапами программы.

## Используемые технологии
- **C++**
- **OpenMP**
- `omp_get_wtime()` для профилирования
