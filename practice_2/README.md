# Practice 2 - Sorting Algorithms (Sequential vs OpenMP)

## Описание
В данной практической работе реализованы классические алгоритмы сортировки
и выполнено сравнение **последовательных** и **параллельных (OpenMP)** версий.
Основная цель - изучить влияние параллельного программирования на
производительность алгоритмов сортировки при разных размерах входных данных.

---

## Реализованные алгоритмы

### Последовательные версии
- Пузырьковая сортировка (Bubble Sort)
- Сортировка выбором (Selection Sort)
- Сортировка вставками (Insertion Sort)

### Параллельные версии (OpenMP)
- Пузырьковая сортировка - параллельная odd-even версия
- Сортировка выбором - параллельный поиск минимума
- Сортировка вставками - параллельная сортировка блоков с последующим слиянием

---

## Условия эксперимента
- Использовалась библиотека `<chrono>` для измерения времени
- Количество потоков OpenMP: **12**
- Размеры массивов:
  - 1 000 элементов
  - 10 000 элементов
  - 100 000 элементов

---

## Результаты производительности

### N = 1000
- Bubble: seq = 1 ms, omp = 101 ms  
- Selection: seq = 1 ms, omp = 93 ms  
- Insertion: seq = 0 ms, omp = 0 ms  

### N = 10 000
- Bubble: seq = 267 ms, omp = 953 ms  
- Selection: seq = 186 ms, omp = 725 ms  
- Insertion: seq = 11 ms, omp = 0 ms  

### N = 100 000
- Bubble: seq = 33607 ms, omp = 10871 ms  
- Selection: seq = 20443 ms, omp = 9377 ms  
- Insertion: seq = 1132 ms, omp = 46 ms  

---

## Анализ результатов
Для малых массивов параллельные версии работают медленнее из-за накладных
расходов на создание потоков и синхронизацию.  
При увеличении размера массива преимущества параллельного выполнения становятся
более заметными. Наибольшее ускорение показала сортировка вставками в
параллельной реализации.

---

## Выводы
1. Параллельное программирование неэффективно для малых объёмов данных.
2. Для больших массивов OpenMP может значительно ускорить выполнение сортировки.
3. Алгоритмы с сильными зависимостями между итерациями плохо масштабируются.
4. Эффективность параллельной сортировки зависит от алгоритма, размера данных и
   числа потоков.

---

## Сборка и запуск

```bash
g++ -O2 -std=c++17 -fopenmp main.cpp -o sort_omp.exe
./sort_omp.exe
```
## Контрольные вопросы
#### 1. В чём основные отличия алгоритмов сортировки пузырьком, выбором и вставкой?
Пузырьковая сортировка выполняет попарные обмены соседних элементов, сортировка выбором ищет минимум и ставит его на место, а сортировка вставками поочерёдно вставляет элементы в уже отсортированную часть массива.

#### 2. Почему параллельная реализация сортировки вставкой сложнее для выполнения с использованием OpenMP?
Потому что каждая вставка зависит от результатов предыдущих шагов, из-за чего возникает сильная зависимость между итерациями.

#### 3. Какие директивы OpenMP были использованы для параллельной реализации алгоритмов?
Использовались директивы #pragma omp parallel, #pragma omp parallel for, #pragma omp critical и reduction.

#### 4. Какие преимущества и недостатки параллельной реализации алгоритмов сортировки на CPU?
Преимущество — ускорение для больших массивов. Недостатки — накладные расходы на потоки и синхронизацию, а также плохая масштабируемость некоторых алгоритмов.

#### 5. Как можно измерить производительность программы в C++?
С помощью библиотеки <chrono>, измеряя время выполнения отдельных участков кода.

#### 6. Как изменяется производительность сортировок при увеличении числа потоков?
Сначала производительность может расти, но затем эффект уменьшается или исчезает из-за синхронизации и ограничений по памяти.

#### 7. В каких ситуациях параллельная сортировка может быть менее эффективной, чем последовательная?
При малом размере массива, большом числе потоков и наличии сильных зависимостей между операциями.
