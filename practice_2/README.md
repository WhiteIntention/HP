## Анализ результатов производительности

Тестирование проводилось для массивов размером 1000, 10 000 и 100 000 элементов.
Время выполнения измерялось с помощью библиотеки `<chrono>`.
Количество потоков OpenMP — 12.

### Результаты

**N = 1000**
- Bubble: seq = 1 ms, omp = 101 ms  
- Selection: seq = 1 ms, omp = 93 ms  
- Insertion: seq = 0 ms, omp = 0 ms  

Для малого размера массива параллельные версии работают значительно медленнее
из-за накладных расходов на создание потоков и синхронизацию.

---

**N = 10000**
- Bubble: seq = 267 ms, omp = 953 ms  
- Selection: seq = 186 ms, omp = 725 ms  
- Insertion: seq = 11 ms, omp = 0 ms  

При среднем размере массива параллельные версии пузырьковой сортировки и
сортировки выбором всё ещё уступают последовательным.
Для сортировки вставками параллельная версия показывает лучшую производительность.

---

**N = 100000**
- Bubble: seq = 33607 ms, omp = 10871 ms  
- Selection: seq = 20443 ms, omp = 9377 ms  
- Insertion: seq = 1132 ms, omp = 46 ms  

Для большого массива параллельные версии значительно быстрее последовательных,
особенно для сортировки вставками, где ускорение наиболее заметно.

---

## Выводы

1. Для малых массивов параллельное программирование неэффективно из-за больших
   накладных расходов OpenMP.
2. При увеличении размера массива преимущества параллельной обработки становятся
   заметными.
3. Пузырьковая сортировка и сортировка выбором имеют сильные зависимости между
   итерациями, поэтому их ускорение ограничено.
4. Сортировка вставками в параллельной реализации показала наибольшее ускорение
   на больших массивах.
5. Эффективность параллельных сортировок зависит от алгоритма, размера данных и
   числа потоков.
