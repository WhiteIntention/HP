# Задание 9.3 — Параллельный поиск кратчайших путей (Флойд–Уоршелл) с MPI + время выполнения

## Цель
Реализовать параллельный алгоритм Флойда–Уоршелла для поиска кратчайших путей
во взвешенном графе и оценить время выполнения программы.

В реализации используются:
- `MPI_Scatter` для распределения строк матрицы смежности между процессами;
- `MPI_Allgather` для обмена обновлёнными строками после каждой итерации `k`;
- `MPI_Gather` для сборки итоговой матрицы на `rank = 0`;
- `MPI_Wtime()` для измерения времени выполнения.

---

## Краткое описание алгоритма
1. На `rank = 0` генерируется матрица смежности `G` размера `N×N`:
   - `G[i][i] = 0`;
   - отсутствующие рёбра задаются как `INF`;
   - веса рёбер генерируются случайно.
2. Строки матрицы распределяются между процессами через `MPI_Scatter`.
   Если `N` не делится на число процессов, используется padding.
3. Для каждого `k` от `0` до `N-1`:
   - каждый процесс обновляет только свои строки;
   - затем выполняется `MPI_Allgather`, чтобы все процессы получили актуальную матрицу.
4. После завершения итераций результат собирается на `rank = 0` (`MPI_Gather`).
5. Для больших `N` выводится не вся матрица, а несколько контрольных значений.

---

## Измерение времени
Время выполнения измеряется через `MPI_Wtime()` с синхронизацией процессов.
Замер включает основную часть вычислений и коммуникаций (Scatter / цикл FW / обмены Allgather / Gather).

---

## Результаты (np = 4)

### N = 16
- MPI processes = `4`
- Execution time = `0.000327638` seconds

### N = 32
- MPI processes = `4`
- Execution time = `0.000509107` seconds  
- Sample: `d[0][1] = 14`  
- Sample: `d[0][N-1] = 14`

### N = 64
- MPI processes = `4`
- Execution time = `0.00191892` seconds  
- Sample: `d[0][1] = 13`  
- Sample: `d[0][N-1] = 4`

---

## Анализ
- При увеличении `N` время выполнения растёт, что ожидаемо, так как алгоритм Флойда–Уоршелла имеет вычислительную сложность `O(N^3)`.
- В данной MPI-версии важный вклад в время выполнения вносит коммуникация:
  `MPI_Allgather` вызывается на каждой итерации `k` (то есть `N` раз), поэтому при росте `N` увеличиваются и вычисления, и объём обмена данных.
- Для `N = 32` и `N = 64` выводятся контрольные значения кратчайших расстояний, что позволяет убедиться, что алгоритм отработал и вернул конечные расстояния (не `INF`) для некоторых пар вершин.

---

## Вывод
Реализация корректно выполняет параллельный алгоритм Флойда–Уоршелла с использованием
`MPI_Scatter`, `MPI_Allgather` и `MPI_Gather`. Эксперименты показали ожидаемый рост времени выполнения при увеличении размера графа, а также подтвердили работоспособность распределённого обмена данными между процессами.

---

## Команды запуска
```bash
mpicxx -O2 9_3.cpp -o 9_3
mpirun -np 4 ./9_3 16
mpirun -np 4 ./9_3 32
mpirun -np 4 ./9_3 64
