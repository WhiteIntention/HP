# Assignment 1
Содержит 4 папки для 4 задании, 
## Задание 1 (25 баллов)
Реализуйте программу на C++, которая динамически выделяет массив из 50 000 целых
чисел, заполняет его случайными значениями от 1 до 100, вычисляет среднее значение
элементов массива и корректно освобождает выделенную память.
## Задание 2 (25 баллов)
Создайте массив из 1 000 000 целых чисел и реализуйте последовательный алгоритм
поиска минимального и максимального элементов. Замерьте время выполнения алгоритма.
## Задание 3 (25 баллов)
Используя OpenMP, реализуйте параллельный поиск минимального и максимального
элементов массива из задания 2. Сравните время выполнения последовательной и
параллельной реализаций.
## Задание 4 (25 баллов)
Создайте массив из 5 000 000 чисел и реализуйте вычисление среднего значения
элементов массива последовательным способом и с использованием OpenMP с редукцией.
Сравните время выполнения обеих реализаций.

## Ответы на контрольные вопросы.
### 1. В чём отличие динамического массива от статического массива в языке C++?
Статический массив имеет фиксированный размер и создаётся при компиляции, а динамический создаётся во время выполнения и требует ручного освобождения памяти.

### 2. Что такое указатель и зачем он используется при работе с динамической памятью?
Указатель хранит адрес в памяти и используется для доступа к динамически выделенному массиву и его освобождения.

### 3. Почему важно корректно освобождать память после использования динамических массивов?
Чтобы избежать утечек памяти и избыточного потребления ресурсов.

### 4. В чём разница между последовательной и параллельной обработкой массива?
Последовательная обработка выполняется одним потоком, а параллельная — несколькими потоками одновременно.

### 5. Что делает директива #pragma omp parallel for?
Она распределяет итерации цикла for между несколькими потоками для параллельного выполнения.

### 6. Для чего используется механизм reduction в OpenMP?
Для безопасного объединения частичных результатов, вычисленных разными потоками.

### 7. Почему при параллельном вычислении суммы необходимо использовать reduction, а не обычную переменную?
Чтобы избежать гонки данных и получить корректный результат.

### 8. Какие факторы могут привести к тому, что параллельная версия программы будет работать медленнее последовательной?
Накладные расходы на потоки, синхронизация, ограниченная пропускная способность памяти и небольшая вычислительная нагрузка.
