# Сравнение производительности CPU и GPU (CUDA)

## Цель
Сравнить время выполнения сортировок на CPU и GPU (CUDA) для разных размеров массива.

Алгоритмы:
- Merge Sort (сортировка слиянием)
- Quick Sort (быстрая сортировка)
- Heap Sort (пирамидальная сортировка)

## Размеры данных
Тестирование проводится для:
- 10 000
- 100 000
- 1 000 000 элементов

## Как измеряется время
### CPU
Используется `std::chrono::high_resolution_clock`.

### GPU
Измеряются два времени:
- `kernel` - время выполнения CUDA-ядер (cudaEvent)
- `total` - общее время с копированием памяти (chrono)

## Файлы
- `benchmark.cu` - код бенчмарка (CPU + GPU)
- `block.png` - блок-схема
- `screenshot.png` - результаты запуска

## Компиляция (для NVIDIA T4):
```bash
nvcc -O2 benchmark.cu -o bench -gencode arch=compute_75,code=sm_75
```
## Контрольные вопросы:

#### Различие последовательной и параллельной сортировки слиянием
Последовательная версия сливает части по очереди одним потоком CPU. Параллельная - делит массив на части и выполняет сортировку/слияние одновременно (на GPU/CPU), чтобы несколько блоков/потоков работали параллельно.

#### Как потоки и блоки влияют на производительность CUDA
Они определяют, сколько работы выполняется одновременно. Если блоков/потоков мало - GPU недогружен. Если слишком много и работа мелкая - растут накладные расходы (запуски kernel, синхронизации, память).

#### Сложности быстрой сортировки на GPU
QuickSort “неровный”: после разбиения получаются сегменты разного размера, много ветвлений и зависимостей. Ещё сложно делать эффективный partition (обычно нужен prefix-sum/scan), а мелких сегментов становится много overhead.

#### Когда GPU-сортировка может быть хуже CPU
На маленьких массивах и при частых копированиях CPU-GPU. Также когда алгоритм плохо распараллеливается (много зависимостей/ветвлений) и когда накладные расходы kernel и синхронизации больше, чем выигрыш.

#### Почему важно выбирать размер блоков и потоков
От этого зависит загрузка SM, скрытие задержек памяти и occupancy. Неподходящий размер может дать мало параллелизма или наоборот перегрузить ресурсы (регистры/Shared Memory) и замедлить.

#### Как shared memory влияет на производительность сортировки
Shared memory быстрее глобальной. Если часть сортировки (например, сортировка чанка) делать в shared, уменьшаются обращения к глобальной памяти обычно быстрее. Но shared ограничена по объёму, и нужно аккуратно синхронизироваться.

#### Что значит “разделяй и властвуй” в сортировках
Алгоритм делит задачу на подзадачи (части массива), решает их отдельно и объединяет результат. Примеры: MergeSort делит и потом сливает, QuickSort делит по pivot и сортирует части отдельно.
