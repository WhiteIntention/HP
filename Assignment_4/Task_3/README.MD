# Assignment 4 - Task 3 (25 pts)
## Гибридная обработка массива: CPU + GPU параллельно (сравнение CPU / GPU / Hybrid)

В этом задании реализована **гибридная программа**, где массив обрабатывается **одновременно** на CPU и GPU:
- **первая часть массива** вычисляется на CPU,
- **вторая часть массива** вычисляется на GPU (CUDA),
- затем результаты объединяются в один выходной массив.

Также выполнено сравнение времени выполнения трёх реализаций:
1) CPU-only  
2) GPU-only  
3) Hybrid (CPU + GPU одновременно)


---

## Реализации

### 1) CPU-only
Последовательный цикл на CPU, обрабатывает весь массив `0..N`.

### 2) GPU-only
CUDA-ядро обрабатывает весь массив `0..N`.  
Время в выводе — это **только время выполнения ядра (kernel time)**, измеренное через `cudaEvent`.

### 3) Hybrid CPU+GPU
Массив делится пополам:
- CPU: `[0 .. split)`
- GPU: `[split .. N)`

Выполнение идёт параллельно:
- CPU часть запускается в `std::thread`
- GPU часть запускается CUDA-ядром
- затем выполняется копирование GPU-результата обратно на host и сборка общего результата

> Важно: в hybrid-времени учитываются накладные расходы на копирование данных между CPU и GPU для второй части массива.

## Параметры эксперимента
- Размер массива: `N = 1 000 000`
- Коэффициент: `k = 3.5`
- Разделение: `split = 500 000` (50% CPU / 50% GPU)
- Конфигурация CUDA:
  - `Block = 256`
  - `Grid = ceil(N / 256)` для GPU-only
  - `Grid2 = ceil((N - split) / 256)` для GPU части в hybrid

## Результаты (фактический вывод)
Assignment 4 - Task 3: Hybrid CPU+GPU array processing
Operation: out[i] = in[i] * k
N = 1000000, k = 3.5
Split: CPU [0..500000), GPU [500000..1000000)
GPU block = 256
CPU-only time (ms) = 0.643957 | max err = 0.000000
GPU-only kernel time (ms) = 0.042368 | max err = 0.000000
Hybrid total time (ms) = 1.241405 | max err = 0.000000

## Таблица сравнения
| Реализация | Время (ms) | Что измерено | Корректность |
|-----------|-----------:|--------------|--------------|
| CPU-only  | 0.643957   | вычисления на CPU | max err = 0 |
| GPU-only  | 0.042368   | **только kernel time** | max err = 0 |
| Hybrid    | 1.241405   | CPU+GPU параллельно **+ копирования** | max err = 0 |

## Анализ результатов
### Корректность
Во всех вариантах:
- `max err = 0.000000`
- значит вычисления совпадают с эталонным результатом.

### Производительность
- GPU-only показал минимальное время выполнения ядра (**0.042 ms**), т.к. операция простая и хорошо параллелится.
- Hybrid оказался **медленнее CPU-only**, несмотря на параллельное выполнение.

Причина:
- операция `out[i] = in[i] * k` очень лёгкая, и основное время в hybrid уходит не на вычисления, а на:
  - `cudaMemcpy` (копирование второй половины на GPU),
  - `cudaMemcpy` обратно (результат),
  - синхронизацию `cudaDeviceSynchronize()`,
  - накладные расходы организации параллелизма.
То есть в данном случае **стоимость обмена данными CPU↔GPU** превышает выигрыш от параллельных вычислений.

## Вывод
Гибридный подход (CPU+GPU) эффективен, когда:
- вычисления на GPU достаточно тяжёлые,
- данные либо уже находятся на GPU, либо копирования можно минимизировать.
Для простой поэлементной операции умножения при `N = 1 000 000` гибридная реализация оказалась медленнее CPU-only из-за больших накладных расходов на передачу данных между CPU и GPU.                             
